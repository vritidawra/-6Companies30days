Q1 https://leetcode.com/problems/evaluate-reverse-polish-notation/
Evaluate Reverse Polish Notation
You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.
Evaluate the expression. Return an integer that represents the value of the expression.
Input: tokens = ["2","1","+","3","*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9

Solution:
class Solution {
public:
    int eval(int a, int b,string y){
        if(y=="+") return b+a;
        if(y=="-") return b-a;
        if(y=="*") return long(a)*b;
        return b/a;
    }
    int evalRPN(vector<string>& tokens) {
        stack<int>s;
        for(auto &a:tokens){
            if(a=="+"||a=="-"||a=="*"||a=="/"){
                int x=s.top();
                s.pop();
                int y=s.top();
                s.pop();
                s.push(eval(x,y,a));
            }
            else{
                s.push(stoi(a));
            }
        }
        return s.top();
    }
};






Q2  Combination Sum III (https://leetcode.com/problems/combination-sum-iii/description/)
Find all valid combinations of k numbers that sum up to n such that the following conditions are true:

    Only numbers 1 through 9 are used.
    Each number is used at most once.

Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.

Example 1:

Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.

Solution
class Solution {
public:
    void solve(int ind,int sum,int k,int n,vector<vector<int>>&ans,vector<int>&v){
        if(sum==n && k==0){
            ans.push_back(v);
            return;
        }
        if(sum>n) return;
        for(int i=ind;i<=9;i++){
            if(i>n) break;
            v.push_back(i);
            solve(i+1,sum+i,k-1,n,ans,v);
            v.pop_back();
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<int>v;
        vector<vector<int>>ans;
        solve(1,0,k,n,ans,v);
        return ans;        
    }
};
//baacktracking
//T->O(2^N ) && S->O(N) [Recusion stack space] && S->O(k * x) [memory for ans]









Q3 Bulls and Cows https://leetcode.com/problems/bulls-and-cows/description/
You are playing the Bulls and Cows game with your friend.

You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:

    The number of "bulls", which are digits in the guess that are in the correct position.
    The number of "cows", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.

Given the secret number secret and your friend's guess guess, return the hint for your friend's guess.

The hint should be formatted as "xAyB", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.
Example 1:

Input: secret = "1807", guess = "7810"
Output: "1A3B"
Explanation: Bulls are connected with a '|' and cows are underlined:
"1807"
  |
"7810"

SOLUTION
class Solution {
public:
    string getHint(string secret, string guess) {
        unordered_map<char,int> mp;
        int bull=0,cow=0;
        for(int i=0;i<secret.size();i++){
            if(secret[i]==guess[i]) bull++;
            else{
                mp[secret[i]]++;
            }
        }
        for(int i=0;i<guess.size();i++){
            if(secret[i]==guess[i])continue;
            else if(mp[guess[i]]>0){
                cow++;
                mp[guess[i]]--;
            }
        }
        string ans="";
        ans=to_string(bull)+"A"+to_string(cow)+"B";
        return ans;
    }
};










Q4 Rotate Function https://leetcode.com/problems/rotate-function/description/
You are given an integer array nums of length n.

Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:

    F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].

Return the maximum value of F(0), F(1), ..., F(n-1).
SOLUTION
eg- A = [4, 3, 2, 6]

F(0) = 0A + 1B + 2C +3D
F(1) = 0D + 1A + 2B +3C
F(2) = 0C + 1D + 2A +3B
F(3) = 0B + 1C + 2D +3A

sum = 1A + 1B + 1C + 1D

F(1)-F(0) = a+b+c-3d
= a+b+c+d - 4d
= sum - n * Bk[0];
F(1) = F(0) + sum - n*Bk[0]
(where B[0] is the first element when array is rotated k-times).

Similarly,
F(1) = F(0) + sum - 4D
F(2) = F(1) + sum - 4C
F(3) = F(2) + sum - 4B

So,

F(k) = F(k-1) + sum - nBk[0]

What is Bk[0]?

k = 0; B[0] = A[0];
k = 1; B[0] = A[len-1];
k = 2; B[0] = A[len-2];

CODE
class Solution {
public:
    int maxRotateFunction(vector<int>& nums) {
        int n = nums.size();
        int sum=0,curr=0;
        for(int i=0;i<n;i++){
            sum+=nums[i];
            curr+=i*nums[i];
        }
        int ans=curr;
        for(int i=n-1;i>0;i--){
            curr=curr+sum-n*nums[i];
            ans=max(ans,curr);
        }
        return ans;
    }
};




